---
title: JS笔记但是不全
---
# JS学习笔记

####输出语句
>alert("");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//警告框显示——函数
>console.log('');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//在控制台显示——方法
>document.write('');&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//向网页中输出
###**编写位置**
+ 网页内部的scripy标签
+ 外部js文件，通过script标签进行引入
    + < script src="" >
+ 编写到指定的属性中
###**基本语法**
+ 区别大小写
+ 多个空格与换行会被忽略
    + 可以以此进行格式化
+ js中每条语句都应该以封号结尾
    + js具有自动添加封号的机制
###**字面量和变量**
####**字面量**
+ 就是一个值，所代表含义就是字面意思
+ 在js中，所有字面量都可以直接使用
+ 但是直接使用并不方便
####**变量**
+ 可以用来“存储”字面量
+ 存储的字面量可以随意地修改
+ 通过变量可以描述字面量，变量比较方便修改
+ let/var 变量名 声明变量
+ a = ** 变量赋值
+ 动态类型（没有类型）
####**常量**
+ 声明 const
####**标识符**
在js中，所有可以由我们自主命名的

+ 只由字母、数字、下划线、$，且不能以数字开头
+ 不能是关键字和保留字，也不建议使用内置的函数和类名
+ 命名规范
    + 驼峰命名法
        + 首字母小写，每个单词开头大写
        + maxLength
        + borderLeftWidth
        + 类名使用大驼峰
        + MaxLength
        + 常量的字母全部大写
        + MAX_LENGTH

####**数值**
#####**1.数值（Number)**
+ 在js中所有整数和浮点数都属于Number
+ js中数值不是无限大的，超过一定值显示近似值
+ Infinity表示无穷大
+ 要注意计算中的精度
+ NaN表示非法计算(Not a Number)
#####**2.大整数(BigInt)**
+ 表示一些特别大的整数
+ 大整数以n结尾，它可以表示的数字范围是内存以内无限大
#####**3.其他进制的数字**
+ 二进制 0b
+ 八进制 0o
+ 十六进制 0x
#####**4.字符串(string)**
+ 字符串中使用单引号或双引号来表示字符串
+ 转义字符\
+ 单引号中可以嵌套双引号
+ 模板字符串
    + 使用反单引号来表示模板单引号
    + 模板字符串中可以嵌入变量
    + >'$(变量名)'
#####**5.布尔值(boolean)**
+ 逻辑判断真假
+ true or false 
#####**6.空值(null)**
+ 空值表示空对象
+ 空值只有一个null
+ 使用typeof检查空值会返回object
+ 使用typeof无法检查空值
#####**7.未定义(undefined)**
+ 当声明后为赋值则为
+ 类型值只有一个，即为undefined
#####**8.符号(Symbol)**
> let c = Symbol

+ 用来创造一个唯一的标识

>JS一共有其中原始值（以上除其他进制的数字外的其他）
>原始值在JS中一经创建无法改变
####**类型检查**
typeof 运算符 返回数值的类型
####**类型转换**
类型转换指将一组数据类型转换为其他类型
主要是将其他类型转换为字符串、数值和布尔值
####转换为字符串
1、调用toString()方法将其他类型转换为字符串
>调用 xxx 的 yyy 方法——>xxx.yyy()
>a.toString()——根据a数值创建一个字符串，对a无影响
a = a.toString()——将a转换为字符串类型
——null 和 undefined 没有toString()，调用会报错

2、调用String()函数将其他类型转换为字符串
>b = String(b)
对拥有 toString()，本质是调用toString()
null 和 undefined 没有toString(),则直接转换
####转换为数值
1、使用 Number() 函数

+ 转换的情况：
    + 如果字符串是一个合法的数字，则正常转换
    + 如果不是合法数字，则转换为NaN
    + 如果字符串是空串或纯空格的字符串，转换为0
    + true->1   false->0
    + null 转换为0
    + undefined 转换为NaN

>a = Number( a )

2、专门用来转换字符串为书hi的方法

+ parseInt()——将一个字符串转换为整数
    + 自左向右读取所有有效字符，遇到无效停止（限于整数位）
    + 也可用来对数字取整
+ parseFloat()——将一个字符串转换为浮点数
    + 自左向右读取所有有效字符，遇到无效停止（可读小数位）

>传的不是字符串，则会先转换成字符串在转换为数值

####转换为布尔值
1、使用Boolean() 将其他类型转换为布尔值

+ 转换的情况
    + 数字：0、NaN->false 其他都为true
    + 字符串：''->false 其余都为true
    + null 和 undefined 都转换为false
    + 对象会转换为true
+ 所有标志空性的没有错误的值都会转换为false
    + 0、NaN、''、null、undefined、false

##**运算符（操作符）**
###**算数运算符**
运算符可以用来对一个或多个操作数（值）进行运算

+ 算术运算符：+、-、*、/、幂运算2*、模运算%
+ 算术运算时，除了字符串的加法，其余运算的操作数时非数值时，都会先转换成数值来完成运算
+ JS时一门弱类型语言，当进行运算时或通过自动的类型转换来完成运算
+ 当任意一个值和字符串做加法运算时，它会先将其他值转换为字符串，然后再做拼串的操作
###**赋值运算符**
赋值运算符用来将一个值赋值给一个变量

+ =
+ +=
+ ......
+ ??= 空赋值
    + 只有当变量为null 或 undefined 时才会赋值成功

###**一元的正负**
+ +：正好
    + 不会改变数值的符号
+ -：负号
    + 可以对数值进行符号位取反

###**自增和自减**

##**对象**
######约等于结构体？
###数据类型

+ 原始值
+ 对象
    + 对象时JS中的一种复合数据类型
        + 它相当与一个容器，子啊对象中可以存储各种不同的类型数据
        > let boj = new Object()
对象中可以存储各种不同类型的数据
对象中存储的数据，我们称为属性

####向对象中添加属性
>对象.属性名 = 属性值

####读取对象中的属性
>对象.属性名

###属性名
+ 通常属性名就是一个字符串，所以属性名可以是任何值，没什么特殊要求
    + 但是若属性名太特殊，需要用“[”“]”来设置
    + 虽然如此，任然建议按照标识符的规范来命名
+ 也可以通过符号( symbol )作为属性名来添加属性
    + 获取这种属性时，也必须使用 symbol
> let mysymbol = Symbol()
obj[mySymbol] = "通过 symbol 添加的属性"
+ symbol添加的属性通常不希望外界获取
+ “[”“]”一般调用的属性名为变量
###属性值
+ 属性值可以为任意数据类型，也可以使用变量
+ in 运算
>属性名 in obj
有返回true，没有返回false
###**创建方法2：**
>let obj2 = {}

+ 此方法创建的对象可以直接添加属性
###**枚举属性**
+ 指将对象中所有的属性全部获取
+ for-in语句
    + for(let propName in 对象){ 语句... }
    + for-in 执行次数==属性个数
        + 每次执行时，都会将属性值赋值给propName
    + 并不是所有的属性都可以枚举，比如使用符号添加的属性
###**可变类型**
+ 原始值都属于不可变类型，一旦创建无法修改
+ 在内存中不会创建重复的原始值
+ 对象属于可变类型
+ 对象创建完成后，可以任意添加删除修改对象中的属性
    + 如果两个变量指向同一对象
        + 通过一个变量改变对象，另一变量也发生改变
###**改变量和改对象**
+ 修改对象
    + 修改对象时，如果有其他变量指向该对象，则所有指向该对象的变量都会受到影响
+ 修改变量
    + 修改变量时，只会影响当前的变量
+ 在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以在通常情况下，声明存储对象的变量时会使用const
+ const只是禁止变量被赋值，对对象的修改没有任何影响
##**函数(function)**
+ 函数也是一个对象
+ 它就具有其他对象所有的功能
+ 函数中可以存储代码，且可以在需要时调用这些代码
>function 函数名 {}
调用：
函数名()

###**函数的定义方式**
####**函数声明**
>function 函数名 {}
####**函数表达式**
>const fn2 = function(){}
####**箭头函数**
> fn3 = () => 语句
> fn4 = () => {语句...}

####**JS不会检查参数类型，可以传任意类型**
####**箭头函数返回值**
+ 箭头函数的返回值可以直接写在箭头后
    + 如果直接在箭头后设置对象字面量为返回值，对象字面量必须用“()”括起来
###**作用域链**
+ 当我们使用一个变量时，JS优先在当前作用域查找，无,则向外寻找
+ 全局都无则报错
###**方法**
通过对象调用叫方法，直接调用叫函数
##**Window对象**
+ 在浏览器中，浏览器为我们提供了一个Window对象，可以直接访问
+ Window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作。除此之外Window还负责存储JS中内置的对象和浏览器的宿主对象
+ Window对象的属性可以通过Window对象访问，也可以直接访问
+ 函数就可以认为是Window对象的方法
+ 向Window对象中添加的属性自动成为全局变量
+ var 用来声明变量，作用和let 相同，但是var 不具有块作用域
    + 在全局中使用var 声明的变量，会作为Window的对象的属性保存
    + 使用function 声明的函数，都作为Window 的方法存在
    + 使用let 声明的变量不会存储在Window对象中 ，而存在一个秘密的小地方
+ var 虽然没有块作用域，但有函数作用域
+ **在局部作用域中，若创建变量不适用var 或let 则被认为创建了一个全局变量**
###**变量的提升**
+ 使用var 声明的变量，它会在所有代码执行前声明（但赋值不提前）
###**函数的提升**
+ 使用函数声明创建的函数，会在其他代码执行前被创建，所有我们可以在函数声明前调用函数
####**let 声明的变量实际上也会提升，但是不可以在声明前访问**
###**debug**
>debugger       断点


###
在开发中应尽量减少直接在全局作用域中编写代码
要精良编写局部作用域
如果使用let 声明的变量，可以使用{}来创建块作用域
###


###**立即执行函数(IIFE)**
+ 立即是一个匿名的函数，且它只会调用一次
+ 可以利用IIFE 来创建一个一次性的函数作用域，避免变量冲突的问题
>(functioin(){
...
...
}());

##**this**
+ 函数在执行时，JS解析器每次都会传递进一个隐含的参数
+ 这个参数叫做this
+ this 会指向一个对象
    + this 所指向的对象会根据函数调用方式的不同而不同
        + 以函数形式调用时，this 指向的是window
        + 以方法的形式调用时，this 指向的时调用方法的对象

箭头函数：
>([参数]) => 返回值

箭头函数的this：
+ 没有自己的this，它的this 由外层作用域决定
+ 箭头函数的this 和它的调用方式无关
##**严格模式**
JS运行代码的方式有两种：

+ 正常模式
    + 默认情况下代码都运行在正常模式
        + 在正常情况下，语法检查并不严格
        + 它的原则是，能不报错就尽量不报错
    + 这种处理方式导致代码的运行性能较差
+ 严格模式
    + 在严格模式下，语法检查变得严格
        + 禁止一些语法
        + 更容易报错
        + 提升了性能
+ 开发中尽量使用严格模式

>"use strict"   开启严格模式

##**面向对象编程（OOP）**
#**DOM**
+ 要使用DOM来操作网页，我们需要浏览器至少得先给我们一个对象才能去完成各种操作
+ 所以浏览器已经给了我们一个document ，它是一个全局变量可以直接使用（document 代表的是整个网页）
##**document 对象**
+ document 对象表示的是整个网页
+ document 对象的原型链
    + HTMLDocument -> Document -> Node -> EventTarget -> Object.prototype -> null
+ 凡是在原型链上存在的对象的属性和方法都可以通过Document 去调用
+ 部分属性
    + document. documentElement --> html根元素
    + document. head --> head元素
    + document. title --> title元素
    + document. body --> body元素
    + document. links --> 获取页面中所以的超链接
##**元素节点**
+ 元素节点对象（element）
    + 在网页中，每一个标签都是一个元素节点
    + 如何获取元素节点？
        + 通过document 对象来获取元素节点
        + 通过document 对象来创建元素节点
    + 通过document 来获取已有的元素节点
        + document. getElementByID()
            + 根据ID获取一个元素节点对象
        + document. getElementsByClassName()
            + 根据元素的class 属性值获取一组元素节点对象
            + 返回的是一个类数组对象
            + 该方法返回的结果是一个实时更新的集合
        + document. getElementsByTagName()
            + 根据标签名获取一组元素节点对象
            + 返回的结果是可以实时更新的集合
            + document. getElementsByTagName("*") 获取页面中所有的元素
            + 根据name 属性获取一组元素节点对象
            + 返回一个实时更新的集合
            + 主要用于表单项
        + document. querySelectorAll()
            + 根据选择器去页面中查询元素
            + 会返回一个数组（不会实时更新）
        + document. querySelector()
            + 根据选择器去页面中查询第一个符合条件的元素
    + 创建一个元素节点
        + document. creatElement()
            + 根据标签名创建一个元素节点对象
###**元素节点**
+ div 元素的原型链
    + HTMLDivElement -> HTMLElement -> Element -> Node -> EventTarget
    + 通过元素节点对象获取其他节点的方法
        + elements. childNodes 获取当前元素的子节点（会包含空白的子节点）
        + elements. children 获取当前元素的子元素
        + elements. firstchild
        + elements. firstElementChild
        + elements. lastElementChild
        + elements. nextElementSibling 获取当前元素的下一个兄弟元素
        + elements. previousElementSibling 获取当前元素的前一个兄弟元素
        + elements. parentNode 获取当前元素的父节点
        + elements. parentElement 获取当前元素的前一个兄弟元素
###
+ 在DOM中，网页中所欲的文本内容都是文本节点对象
    + 可以通过元素来获取其中的文本节点对象，但是我通常不会这么做
    + 我们可以直接通过元素去修改其中的文本
        + 修改文本的三个属性
            + elemtnt. textContent() 获取或修改元素中的文本内容
                + 获取的是标签中的内容，不会考虑css 样式
            + element. innerText 获取或修改元素中的文本内容
                + innerText 获取内容时，会考虑css 样式
                + 通过innerText去读取CSS 样式，会触发网页的重排（计算CSS样式）
                + 当字符串中由标签时，会自动对标签进行转义
            + element. innerHTML 获取或修改元素中的html 代码
                + 可以直接向元素中添加html 代码
                + innerHTML 插入内容时，有被xxs 注入的风险
##**属性节点（Attr）**
+ 在DOM 也是一个对象，通常不需要获取对象而是直接通过元素即可完成对其的各种操作
+ 如何操作属性节点
    + 方式一：
        + 读取：元素. 属性名（注意，class 属性需要使用className 来读取）
            + 读取一个布尔值时，会返回true 或false
        + 修改：元素. 属性名 = 属性值
    + 方式二：
        + 读取：元素. getAttribute(属性名)
        + 修改：元素. setAttributr(属性名,属性值)
        + 删除：元素. removeAttributr(属性名)
##**事件（event）**
+ 时间就是用户和页面之间发生的交互行为
    + 比如：点击按钮、鼠标移动、双击案件、敲击键盘、松开案件...
+ 可以通过为实际爱你绑定响应函数（回调函数），来完成和用户之间的交互
+ 绑定响应函数的方式：
    + 可以直接在元素的属性中设置
    + 可以通过为元素的指定属性设置回调函数的形式来绑定事件（一个事件只能绑定一个响应函数）
    + 可以通过元素addEventListener() 方法来绑定事件
##**文档的加载**
+ 网页时自上向下加载的，如果将js代码编写到网页的上边，js代码在执行时，网页还没有加载完毕，这是会出现无法获取DOM 对象的情况
+ window. onload 事件会在窗口的内容加载完毕之后触发
+ document 对象的DOMContentLoaded 事件会在当前文档加载完毕之后触发
+ 如何解决这个问题：
    + 将script 标签编写到body 的最后
    
    + 将代码编写到window. onload 的回调函数中
    + 将代码编写到document 对象的DOMContentLoaded 的回调幻术中
    + 将代码编写到外部的js 文件中，，然后以defer 的形式进行引入（执行时机更早，遭遇DOMContentLoaded）<font color="red">（*****）</font>


###**添加元素到网页**
+ element. appendChild()用于给一个节点添加子节点
+ element. inserAdjacentElement("要添加的位置",ya要添加的元素)
    + beforeend 标签的最后
    + afterbegin    第二个
    + beforebegin
    + afterend 在元素的后边
###**取消默认行为**
+ 使用return false 来取消默认行为（只在xx. xxx =  function(){}这种形式绑定的事件中才适用）
+ 在元素直接添加javascript:;
###**节点复制**
+ element. cloneNode()
    + 不复制子节点
    + 加参数true 复制子节点
##**通过js修改css样式**
+ 修改样式的方法：元素. style. 样式名 = 样式值
+ 如果样式名含有- ，则需要将样式表修改为驼峰命名法
    + background-color --> backgroundColor
##**读取样式**
+ getComputedStyle()
    + 它会返回一个对象，这个对象中包含了当前元素所有的生效的样式
    + 参数：
        + 要获取样式的对象
        + 要获取的伪元素
    + 返回值：返回的一个对象，对象中存储了当前元素的样式
    + 注意：样式对象中返回的样式值，不一定能拿来直接计算，所以使用时，一定要确保值时可以计算的才去计算

+ 元素. clientHeight
+ 元素. clientWidth
    + 获取元素内部的宽度和高度（包括内容区和内边距）

+ 元素. offsetHeight
+ 元素. offsetWidth
    + 获取元素的可见框的大小（包括内容区，内边距和边框）

+ 元素. scrollHeight
+ 元素. scrollWidth
    + 获取元素滚动区域大小
    
+ 元素. offsetParent
    + 获取怨怒是的定位父元素
    + 定位父元素，离当前元素最近的开启了定位的祖先元素，如果所有的元素都没有开启定位则返回body

+ 元素. offsetTop
+ 元素. offsetLeft
    + 获取元素相对于其定位父元素的偏移量

+ 元素. scrollTop
+ 元素. scrollLeft 
    + 获取或设置滚动条的偏移量

+ 除了直接修改样式外，也可以通过修改class 属性来间接地修改样式
+ 通过class 修改样式的好处
    + 可以一次性修改多个样式
    + 对js 和css 进行解耦
+ 元素. classList 是一个对象，对象中提供了对当前元素的类的各种操作方法
+ 元素. ClassList. add() 向元素中添加一个或多个class
+ 元素. ClassList. remove() 向元素中添加一个或多个class
+ 元素. ClassList. toggle() 切换元素中的class
+ 元素. ClassList. replace() 替换class
+ 元素. ClassList. contains() 检查class
##**事件对象（event）**
+ 事件对象
+ 事件对象是有浏览器在事件触发时所创建的对象，这个对象中封装了事件相关的各种信息
+ 通过事件对象可以获取到事件的详细信息
    + 比如：鼠标的坐标、键盘的按键..
+ 浏览器在创建事件对象后，会将事件对象作为响应函数的参数传递，所有我们可以在事件的回调函数中定义一个形参来接收事件对象

+ 在DOM中存在着多种不同类型的事件对象
    + 多种事件对象有一个共同的祖先 Event
        + event. target 触发事件的对象
        + event. currentTarget 绑定事件的对象（同this）
        + event. stopProgpagation()//取消事件的传导
        + event. preventDefault() 取消默认行为
    + 事件的冒泡（bubble）
        + 事件的冒泡就是指事件的向上传导
        + 当元素的上的某个事件被触发后，其祖先元素上的相同事件也会同时被触发
        + 冒泡的存在大大简化了代码的编写，但是在一些场景下我们并不希望冒泡存在，不希望事件冒泡时，可以通过事件对象来取消冒泡
+ 在事件的响应函数中：
    + event. target 表示的时触发事件的对象
    + this 绑定事件的对象
##**事件的委派**
可以将事件统一绑定给document ，这样点击超链接时由于事件的冒泡，会导致document 上的点击事件被触发，，这样只绑定以此，所有的超链接都会具有这些事件
+ 委派就是将本该绑定给多个元素的事件，统一绑定给document ，这样可以降低代码复杂度方便维护
##**事件的捕获**
+ 事件的传播机制：
    + 在DOM中，事件的传播可以分为三个阶段：
        + 捕获阶段（由祖先元素向祖先元素进行事件的捕获）（默认情况下，事件不会在捕获阶段触发）
        + 目标阶段（触发事件的对象）
        + 冒泡阶段（由目标元素向祖先元素进行事件的冒泡）
    + 事件的捕获，指事件从外向内的传导：当前元素触发事件时，会从当前元素最大的祖先元素开始向当前元素进行元素的捕获
    + 如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true，一般情况下我们不希望事件在捕获阶段触发，所有通常都不设置第三个参数
+ event. eventPhase //表示事件触发的阶段
    + 1 捕获阶段；2 目标阶段；3 冒泡阶段
#**BOM**
+ 浏览器对象模型
+ BOM 为我们提供了一组对象，通过这组对象可以完成对浏览器的各种操作
+ BOM对象：
    + Window —— 代表浏览器窗口（全局对象）
    + Navigator —— 浏览器的对象（可以用来识别浏览器）
    + Location —— 浏览器的地址栏信息
    + History —— 浏览器的历史记录（空值浏览器的前进后退）
    + Screen —— 屏幕的信息
+ BOM 对象都是作为Window 对象的属性来保存的，所以可以直接在JS 中访问这些对象
###**Navigator**
+ userAgent 返回一个用来描述浏览器信息的字符串
###**Location**
+ Location 表示的时浏览器的地址栏的信息
    + 可以直接将Location 的值修改为一个新的地址，这样会使得网页发生跳转
    + Location. assign() 跳转到一个新的地址
    + Location. replace() 跳转到一个新的地址（无法通过回退按钮回退）
    + Location. reload() 刷新一个页面，可以传递一个true 来强制清缓存刷新
    + Location. href 获取当前地址
###**History**
+ history. back() —— 回退按钮
+ history. forward() —— 前进按钮
+ history. go( number ) —— 根据数字前进后退
##**定时器**
+ 通过定时器，可以使代码在指定事件后执行
    + 设置定时器的方式有两种
        + setTimeout()
            + 参数：
                + 回调函数（要执行的代码）
                + 间隔的事件（毫秒）
            + 关闭定时器
                + clearTimeout
        + setInterval()（没间隔一段时间就会执行一次）
            + 参数：
                +  回调函数（要执行的代码）
                + 间隔的事件（毫秒）
            + 关闭定时器
                + clearInterval
+ 定时器的本质，就是在指定事件后将函数添加到消息队列中
+ setInterval() 每间隔一段时间添加到消息队列中，但是如果函数执行的速度比较慢，它是无法确保每次执行的间隔是一样的
###**调用栈**
+ 事件循环（event loop）
    + 函数在每次执行时，都会产生一个执行环境
    + 执行环境负责存储函数执行时产生的一切数据
    + 问题：
        + 函数的执行环境存储到了一个叫做调用栈的地方
        + 栈，是一种数据结构，特点 后进先出
        + 队列，是一种数据结构，先进先出
    + 调用栈（call stack）
        + 调用栈负责存储函数的执行环境
        + 当一个函数被调用时，它的执行环境会作为一个栈帧插入到调用栈的栈顶，函数执行完毕其栈帧会自动从栈中弹出
    + 消息队列
        + 消息队列负责存储将要执行的函数
        + 当我们触发一个事件时，其响应函数并不是直接就添加到调用栈中的，因为调用栈中有可能会存在一些还没有执行完的代码
        + 事件触发后，JS引擎是将事件
#**jQuery**
